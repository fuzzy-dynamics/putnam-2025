/-
  Putnam 2025 Problem B2 - Complete Proof (No Axioms, No Sorry)

  Problem: Let f : [0,1] -> [0, infinity) be strictly increasing and continuous.
  Let R be the region bounded by x=0, x=1, y=0, and y=f(x).
  Let x_1 be the x-coordinate of the centroid of R.
  Let x_2 be the x-coordinate of the centroid of the solid generated by rotating R about the x-axis.
  Prove that x_1 < x_2.

  NOTE: The original problem does NOT require f(0) = 0. Our proof works for any
  strictly increasing continuous f : [0,1] -> [0, infinity).

  Solution Strategy (elephant353's auxiliary function method):
  ===========================================================

  Define: A = integral f, B = integral f^2, g(x) = f(x)^2/B - f(x)/A

  Properties of g:
  1. integral g = 0 (integrates to zero)
  2. Since f is strictly increasing, g changes sign exactly once at some a in (0,1).
  3. For t < a: g(t) < 0; for t > a: g(t) > 0

  Key calculation:
    integral (t-a)*g(t) dt > 0 (integrand is nonnegative and positive except at a)
    = integral t*g(t) dt - a * integral g(t) dt
    = integral t*g(t) dt - 0
    = integral t*f(t)^2/B dt - integral t*f(t)/A dt
    = x_2 - x_1

  Therefore x_2 > x_1.
-/

import Mathlib.MeasureTheory.Integral.IntervalIntegral.Basic
import Mathlib.MeasureTheory.Integral.Bochner.Set
import Mathlib.Order.Monotone.Basic
import Mathlib.Topology.Basic
import Mathlib.Analysis.SpecialFunctions.Pow.Real
import Mathlib.Tactic

namespace Putnam2025B2

open MeasureTheory Set Real intervalIntegral Filter Topology

/-! ## Problem Setup -/

/-- A valid function for the B2 problem:
    - Continuous on [0,1]
    - Strictly increasing on [0,1]
    - f(x) >= 0 on [0,1]
    Note: We do NOT require f(0) = 0; the problem only states f : [0,1] -> [0,∞) -/
structure ValidFunction (f : ℝ → ℝ) : Prop where
  continuous : ContinuousOn f (Icc 0 1)
  strictly_increasing : StrictMonoOn f (Icc 0 1)
  range_nonneg : ∀ x ∈ Icc 0 1, f x ≥ 0

/-- The x-coordinate of the centroid of region R under f -/
noncomputable def centroid_region (f : ℝ → ℝ) : ℝ :=
  (∫ x in (0:ℝ)..1, x * f x) / (∫ x in (0:ℝ)..1, f x)

/-- The x-coordinate of the centroid of the solid of revolution -/
noncomputable def centroid_solid (f : ℝ → ℝ) : ℝ :=
  (∫ x in (0:ℝ)..1, x * (f x)^2) / (∫ x in (0:ℝ)..1, (f x)^2)

/-! ## Basic Properties -/

lemma f_pos_at_one (f : ℝ → ℝ) (hf : ValidFunction f) : f 1 > f 0 :=
  hf.strictly_increasing (by simp [Icc] : (0:ℝ) ∈ Icc 0 1) (by simp [Icc] : (1:ℝ) ∈ Icc 0 1) (by norm_num : (0:ℝ) < 1)

lemma integrable_f (f : ℝ → ℝ) (hf : ValidFunction f) :
    IntervalIntegrable f volume 0 1 :=
  hf.continuous.intervalIntegrable_of_Icc (by norm_num : (0:ℝ) ≤ 1)

lemma integrable_f_sq (f : ℝ → ℝ) (hf : ValidFunction f) :
    IntervalIntegrable (fun x => (f x)^2) volume 0 1 :=
  (ContinuousOn.pow hf.continuous 2).intervalIntegrable_of_Icc (by norm_num : (0:ℝ) ≤ 1)

lemma integrable_x_f (f : ℝ → ℝ) (hf : ValidFunction f) :
    IntervalIntegrable (fun x => x * f x) volume 0 1 :=
  (ContinuousOn.mul continuousOn_id hf.continuous).intervalIntegrable_of_Icc (by norm_num : (0:ℝ) ≤ 1)

lemma integrable_x_f_sq (f : ℝ → ℝ) (hf : ValidFunction f) :
    IntervalIntegrable (fun x => x * (f x)^2) volume 0 1 :=
  (ContinuousOn.mul continuousOn_id (ContinuousOn.pow hf.continuous 2)).intervalIntegrable_of_Icc (by norm_num : (0:ℝ) ≤ 1)

/-- f(1) > 0 since f is strictly increasing and nonnegative -/
lemma f1_pos (f : ℝ → ℝ) (hf : ValidFunction f) : f 1 > 0 := by
  have h1 : f 1 > f 0 := f_pos_at_one f hf
  have h2 : f 0 ≥ 0 := hf.range_nonneg 0 ⟨le_refl 0, by norm_num⟩
  linarith

/-- The integral of f over [0,1] is positive -/
lemma integral_f_pos (f : ℝ → ℝ) (hf : ValidFunction f) :
    ∫ x in (0:ℝ)..1, f x > 0 := by
  apply intervalIntegral.integral_pos
  · norm_num
  · exact hf.continuous
  · intro x hx  -- hx : x ∈ Ioc 0 1 means 0 < x ∧ x ≤ 1
    exact hf.range_nonneg x ⟨le_of_lt hx.1, hx.2⟩
  · use 1
    constructor
    · constructor <;> norm_num
    · exact f1_pos f hf

/-- The integral of f^2 over [0,1] is positive -/
lemma integral_f_sq_pos (f : ℝ → ℝ) (hf : ValidFunction f) :
    ∫ x in (0:ℝ)..1, (f x)^2 > 0 := by
  apply intervalIntegral.integral_pos
  · norm_num
  · exact ContinuousOn.pow hf.continuous 2
  · intro _ _; exact sq_nonneg _
  · use 1
    constructor
    · constructor <;> norm_num
    · exact pow_pos (f1_pos f hf) 2

/-! ## Auxiliary Function Approach -/

noncomputable def aux_g (f : ℝ → ℝ) (A B : ℝ) (x : ℝ) : ℝ :=
  (f x)^2 / B - f x / A

lemma aux_g_continuousOn (f : ℝ → ℝ) (hf : ValidFunction f) (A B : ℝ)
    (_hA : A ≠ 0) (_hB : B ≠ 0) : ContinuousOn (aux_g f A B) (Icc 0 1) := by
  unfold aux_g
  have hcont_f_sq : ContinuousOn (fun x => (f x)^2) (Icc 0 1) := ContinuousOn.pow hf.continuous 2
  exact ContinuousOn.sub (hcont_f_sq.div_const B) (hf.continuous.div_const A)

lemma aux_g_integral_zero (f : ℝ → ℝ) (hf : ValidFunction f) :
    let A := ∫ t in (0:ℝ)..1, f t
    let B := ∫ t in (0:ℝ)..1, (f t)^2
    ∫ x in (0:ℝ)..1, aux_g f A B x = 0 := by
  intro A B
  have hA_pos := integral_f_pos f hf
  have hB_pos := integral_f_sq_pos f hf
  unfold aux_g
  rw [intervalIntegral.integral_sub, intervalIntegral.integral_div, intervalIntegral.integral_div]
  · rw [div_self (ne_of_gt hB_pos), div_self (ne_of_gt hA_pos)]
    ring
  · exact (integrable_f_sq f hf).div_const B
  · exact (integrable_f f hf).div_const A

lemma aux_g_factor (f : ℝ → ℝ) (A B : ℝ) (hA : A ≠ 0) (hB : B ≠ 0) (x : ℝ) :
    aux_g f A B x = (f x / B) * (f x - B / A) := by
  unfold aux_g
  field_simp [hA, hB]

lemma aux_g_sign_pos (f : ℝ → ℝ) (hf : ValidFunction f) (x : ℝ) (hfx_pos : f x > 0) :
    let A := ∫ t in (0:ℝ)..1, f t
    let B := ∫ t in (0:ℝ)..1, (f t)^2
    aux_g f A B x > 0 ↔ f x > B / A := by
  intro A B
  have hA_pos := integral_f_pos f hf
  have hB_pos := integral_f_sq_pos f hf
  rw [aux_g_factor f A B (ne_of_gt hA_pos) (ne_of_gt hB_pos) x]
  constructor
  · intro hpos
    have h1 : f x / B > 0 := div_pos hfx_pos hB_pos
    by_contra hle; push_neg at hle
    have h2 : f x - B / A ≤ 0 := by linarith
    have h3 : (f x / B) * (f x - B / A) ≤ 0 := mul_nonpos_of_nonneg_of_nonpos (le_of_lt h1) h2
    linarith
  · intro hfx_gt
    have h1 : f x / B > 0 := div_pos hfx_pos hB_pos
    have h2 : f x - B / A > 0 := by linarith
    exact mul_pos h1 h2

lemma aux_g_sign_neg (f : ℝ → ℝ) (hf : ValidFunction f) (x : ℝ) (hfx_pos : f x > 0) :
    let A := ∫ t in (0:ℝ)..1, f t
    let B := ∫ t in (0:ℝ)..1, (f t)^2
    aux_g f A B x < 0 ↔ f x < B / A := by
  intro A B
  have hA_pos := integral_f_pos f hf
  have hB_pos := integral_f_sq_pos f hf
  rw [aux_g_factor f A B (ne_of_gt hA_pos) (ne_of_gt hB_pos) x]
  constructor
  · intro hneg
    have h1 : f x / B > 0 := div_pos hfx_pos hB_pos
    by_contra hge; push_neg at hge
    have h2 : f x - B / A ≥ 0 := by linarith
    have h3 : (f x / B) * (f x - B / A) ≥ 0 := mul_nonneg (le_of_lt h1) h2
    linarith
  · intro hfx_lt
    have h1 : f x / B > 0 := div_pos hfx_pos hB_pos
    have h2 : f x - B / A < 0 := by linarith
    exact mul_neg_of_pos_of_neg h1 h2

/-! ## Existence of Root -/

/-- B/A > f(0): The ratio B/A is strictly greater than f(0) -/
lemma f0_lt_BA (f : ℝ → ℝ) (hf : ValidFunction f) :
    let A := ∫ t in (0:ℝ)..1, f t
    let B := ∫ t in (0:ℝ)..1, (f t)^2
    f 0 < B / A := by
  intro A B
  have hA_pos := integral_f_pos f hf
  have hB_pos := integral_f_sq_pos f hf
  rw [lt_div_iff₀ hA_pos]
  -- Need to show: f(0) * A < B, i.e., f(0) * ∫f < ∫f²
  have key : f 0 * ∫ x in (0:ℝ)..1, f x < ∫ x in (0:ℝ)..1, (f x)^2 := by
    rw [← intervalIntegral.integral_const_mul]
    apply integral_lt_integral_of_continuousOn_of_le_of_exists_lt
    · norm_num
    · exact ContinuousOn.mul continuousOn_const hf.continuous
    · exact ContinuousOn.pow hf.continuous 2
    · intro x hx  -- hx : x ∈ Ioc 0 1 means 0 < x ∧ x ≤ 1
      have h0_mem : (0:ℝ) ∈ Icc 0 1 := ⟨le_refl 0, by norm_num⟩
      have hx_mem : x ∈ Icc 0 1 := ⟨le_of_lt hx.1, hx.2⟩
      have hf_gt : f x > f 0 := hf.strictly_increasing h0_mem hx_mem hx.1
      have hf_nonneg : f x ≥ 0 := hf.range_nonneg x hx_mem
      calc f 0 * f x ≤ f x * f x := by
            apply mul_le_mul_of_nonneg_right (le_of_lt hf_gt) hf_nonneg
        _ = (f x)^2 := (sq (f x)).symm
    · use 1, ⟨by norm_num, by norm_num⟩
      have h0_mem : (0:ℝ) ∈ Icc 0 1 := ⟨le_refl 0, by norm_num⟩
      have h1_mem : (1:ℝ) ∈ Icc 0 1 := ⟨by norm_num, le_refl 1⟩
      have hf_gt : f 1 > f 0 := hf.strictly_increasing h0_mem h1_mem (by norm_num : (0:ℝ) < 1)
      have hf1_pos : f 1 > 0 := f1_pos f hf
      calc f 0 * f 1 < f 1 * f 1 := by
            apply mul_lt_mul_of_pos_right hf_gt hf1_pos
        _ = (f 1)^2 := (sq (f 1)).symm
  calc f 0 * A = f 0 * ∫ x in (0:ℝ)..1, f x := rfl
    _ < ∫ x in (0:ℝ)..1, (f x)^2 := key
    _ = B := rfl

/-- B/A < f(1): The ratio B/A is strictly less than f(1) -/
lemma BA_lt_f1 (f : ℝ → ℝ) (hf : ValidFunction f) :
    let A := ∫ t in (0:ℝ)..1, f t
    let B := ∫ t in (0:ℝ)..1, (f t)^2
    B / A < f 1 := by
  intro A B
  have hA_pos := integral_f_pos f hf
  have hB_pos := integral_f_sq_pos f hf
  rw [div_lt_iff₀ hA_pos]
  -- Need to show: B < f(1) * A, i.e., ∫f² < f(1) * ∫f
  have key : ∫ x in (0:ℝ)..1, (f x)^2 < ∫ x in (0:ℝ)..1, f 1 * f x := by
    apply integral_lt_integral_of_continuousOn_of_le_of_exists_lt
    · norm_num
    · exact ContinuousOn.pow hf.continuous 2
    · exact ContinuousOn.mul continuousOn_const hf.continuous
    · intro x hx  -- hx : x ∈ Ioc 0 1 means 0 < x ∧ x ≤ 1
      by_cases hx1 : x = 1
      · subst hx1; rw [sq]
      have hx_lt : x < 1 := lt_of_le_of_ne hx.2 hx1
      have hx_mem : x ∈ Icc 0 1 := ⟨le_of_lt hx.1, hx.2⟩
      have h1_mem : (1:ℝ) ∈ Icc 0 1 := ⟨by norm_num, le_refl 1⟩
      have hf_lt : f x < f 1 := hf.strictly_increasing hx_mem h1_mem hx_lt
      have hf_nonneg : f x ≥ 0 := hf.range_nonneg x hx_mem
      calc (f x)^2 = f x * f x := sq (f x)
        _ ≤ f x * f 1 := mul_le_mul_of_nonneg_left (le_of_lt hf_lt) hf_nonneg
        _ = f 1 * f x := by ring
    · use 1/2, ⟨by norm_num, by norm_num⟩
      have h0_mem : (0:ℝ) ∈ Icc 0 1 := ⟨le_refl 0, by norm_num⟩
      have h12_mem : (1:ℝ)/2 ∈ Icc 0 1 := ⟨by norm_num, by norm_num⟩
      have h1_mem : (1:ℝ) ∈ Icc 0 1 := ⟨by norm_num, le_refl 1⟩
      have hf_lt : f (1/2) < f 1 := hf.strictly_increasing h12_mem h1_mem (by norm_num : (1:ℝ)/2 < 1)
      have hf_gt0 : f (1/2) > f 0 := hf.strictly_increasing h0_mem h12_mem (by norm_num : (0:ℝ) < 1/2)
      have hf0_nonneg : f 0 ≥ 0 := hf.range_nonneg 0 h0_mem
      have hf_pos : f (1/2) > 0 := by linarith
      calc (f (1/2))^2 = f (1/2) * f (1/2) := sq (f (1/2))
        _ < f (1/2) * f 1 := mul_lt_mul_of_pos_left hf_lt hf_pos
        _ = f 1 * f (1/2) := by ring
  calc B = ∫ x in (0:ℝ)..1, (f x)^2 := rfl
    _ < ∫ x in (0:ℝ)..1, f 1 * f x := key
    _ = f 1 * ∫ x in (0:ℝ)..1, f x := intervalIntegral.integral_const_mul _ _
    _ = f 1 * A := rfl

/-- There exists a root a in (0,1) where f(a) = B/A -/
lemma exists_root (f : ℝ → ℝ) (hf : ValidFunction f) :
    let A := ∫ t in (0:ℝ)..1, f t
    let B := ∫ t in (0:ℝ)..1, (f t)^2
    ∃ a ∈ Set.Ioo (0:ℝ) 1, f a = B / A := by
  intro A B
  have h_f0_lt := f0_lt_BA f hf
  have h_BA_lt_f1 := BA_lt_f1 f hf
  -- By IVT: Ioo (f 0) (f 1) ⊆ f '' Ioo 0 1
  have := intermediate_value_Ioo (by norm_num : (0:ℝ) ≤ 1) hf.continuous
  have h_mem : B / A ∈ Set.Ioo (f 0) (f 1) := ⟨h_f0_lt, h_BA_lt_f1⟩
  exact this h_mem

noncomputable def root_a (f : ℝ → ℝ) (hf : ValidFunction f) : ℝ :=
  (exists_root f hf).choose

lemma root_a_mem (f : ℝ → ℝ) (hf : ValidFunction f) :
    root_a f hf ∈ Set.Ioo (0:ℝ) 1 :=
  (exists_root f hf).choose_spec.1

lemma root_a_spec (f : ℝ → ℝ) (hf : ValidFunction f) :
    let A := ∫ t in (0:ℝ)..1, f t
    let B := ∫ t in (0:ℝ)..1, (f t)^2
    f (root_a f hf) = B / A :=
  (exists_root f hf).choose_spec.2

/-- f is positive on (0,1] -/
lemma f_pos_on_Ioc (f : ℝ → ℝ) (hf : ValidFunction f) :
    ∀ x ∈ Set.Ioc (0:ℝ) 1, f x > 0 := by
  intro x hx
  have h0_mem : (0:ℝ) ∈ Icc 0 1 := ⟨le_refl 0, by norm_num⟩
  have hx_mem : x ∈ Icc 0 1 := ⟨le_of_lt hx.1, hx.2⟩
  have h1 : f x > f 0 := hf.strictly_increasing h0_mem hx_mem hx.1
  have h2 : f 0 ≥ 0 := hf.range_nonneg 0 h0_mem
  linarith

/-! ## Sign of g relative to root -/

lemma aux_g_neg_before_root (f : ℝ → ℝ) (hf : ValidFunction f) :
    let A := ∫ t in (0:ℝ)..1, f t
    let B := ∫ t in (0:ℝ)..1, (f t)^2
    let a := root_a f hf
    ∀ x ∈ Set.Ioc (0:ℝ) 1, x < a → aux_g f A B x < 0 := by
  intro A B a x hx hxa
  have hfx_pos := f_pos_on_Ioc f hf x hx
  have hfa : f a = B / A := root_a_spec f hf
  have ha_mem := root_a_mem f hf
  have hx_mem : x ∈ Icc 0 1 := ⟨le_of_lt hx.1, hx.2⟩
  have ha_mem' : a ∈ Icc 0 1 := ⟨le_of_lt ha_mem.1, le_of_lt ha_mem.2⟩
  have hfx_lt : f x < B / A := calc f x < f a := hf.strictly_increasing hx_mem ha_mem' hxa
    _ = B / A := hfa
  exact (aux_g_sign_neg f hf x hfx_pos).mpr hfx_lt

lemma aux_g_pos_after_root (f : ℝ → ℝ) (hf : ValidFunction f) :
    let A := ∫ t in (0:ℝ)..1, f t
    let B := ∫ t in (0:ℝ)..1, (f t)^2
    let a := root_a f hf
    ∀ x ∈ Set.Ioc (0:ℝ) 1, x > a → aux_g f A B x > 0 := by
  intro A B a x hx hxa
  have hfx_pos := f_pos_on_Ioc f hf x hx
  have hfa : f a = B / A := root_a_spec f hf
  have ha_mem := root_a_mem f hf
  have hx_mem : x ∈ Icc 0 1 := ⟨le_of_lt hx.1, hx.2⟩
  have ha_mem' : a ∈ Icc 0 1 := ⟨le_of_lt ha_mem.1, le_of_lt ha_mem.2⟩
  have hfx_gt : f x > B / A := calc f x > f a := hf.strictly_increasing ha_mem' hx_mem hxa
    _ = B / A := hfa
  exact (aux_g_sign_pos f hf x hfx_pos).mpr hfx_gt

/-! ## Key Integral Identity -/

lemma key_integral_identity (f : ℝ → ℝ) (hf : ValidFunction f) :
    let A := ∫ t in (0:ℝ)..1, f t
    let B := ∫ t in (0:ℝ)..1, (f t)^2
    ∫ t in (0:ℝ)..1, t * aux_g f A B t = centroid_solid f - centroid_region f := by
  intro A B
  unfold aux_g centroid_solid centroid_region
  have h1 : ∫ t in (0:ℝ)..1, t * ((f t)^2 / B - f t / A) =
            (∫ t in (0:ℝ)..1, t * (f t)^2) / B - (∫ t in (0:ℝ)..1, t * f t) / A := by
    have hsub : ∫ t in (0:ℝ)..1, t * ((f t)^2 / B - f t / A) =
                ∫ t in (0:ℝ)..1, (t * (f t)^2 / B - t * f t / A) := by
      congr 1; ext t; ring
    rw [hsub, intervalIntegral.integral_sub, intervalIntegral.integral_div, intervalIntegral.integral_div]
    · exact (integrable_x_f_sq f hf).div_const B
    · exact (integrable_x_f f hf).div_const A
  rw [h1]

/-! ## Product Positivity -/

lemma integrable_product (f : ℝ → ℝ) (hf : ValidFunction f) :
    let A := ∫ t in (0:ℝ)..1, f t
    let B := ∫ t in (0:ℝ)..1, (f t)^2
    let a := root_a f hf
    IntervalIntegrable (fun t => (t - a) * aux_g f A B t) volume 0 1 := by
  intro A B a
  have hA_pos := integral_f_pos f hf
  have hB_pos := integral_f_sq_pos f hf
  have hcont : ContinuousOn (fun t => (t - a) * aux_g f A B t) (Icc 0 1) :=
    ContinuousOn.mul (continuous_sub_right a).continuousOn
      (aux_g_continuousOn f hf A B (ne_of_gt hA_pos) (ne_of_gt hB_pos))
  exact hcont.intervalIntegrable_of_Icc (by norm_num : (0:ℝ) ≤ 1)

lemma product_nonneg_on_Ioc (f : ℝ → ℝ) (hf : ValidFunction f) :
    let A := ∫ t in (0:ℝ)..1, f t
    let B := ∫ t in (0:ℝ)..1, (f t)^2
    let a := root_a f hf
    ∀ t ∈ Set.Ioc (0:ℝ) 1, (t - a) * aux_g f A B t ≥ 0 := by
  intro A B a t ht
  have ha_mem := root_a_mem f hf
  by_cases hlt : t < a
  · have h1 : t - a < 0 := sub_neg.mpr hlt
    have h2 : aux_g f A B t < 0 := aux_g_neg_before_root f hf t ht hlt
    exact le_of_lt (mul_pos_of_neg_of_neg h1 h2)
  · by_cases hgt : t > a
    · have h1 : t - a > 0 := sub_pos.mpr hgt
      have h2 : aux_g f A B t > 0 := aux_g_pos_after_root f hf t ht hgt
      exact le_of_lt (mul_pos h1 h2)
    · have heq : t = a := le_antisymm (le_of_not_gt hgt) (le_of_not_gt hlt)
      simp [heq]

lemma product_pos_after (f : ℝ → ℝ) (hf : ValidFunction f) :
    let A := ∫ t in (0:ℝ)..1, f t
    let B := ∫ t in (0:ℝ)..1, (f t)^2
    let a := root_a f hf
    ∀ t ∈ Set.Ioc (0:ℝ) 1, t > a → (t - a) * aux_g f A B t > 0 := by
  intro A B a t ht hgt
  have h1 : t - a > 0 := sub_pos.mpr hgt
  have h2 : aux_g f A B t > 0 := aux_g_pos_after_root f hf t ht hgt
  exact mul_pos h1 h2

/-! ## Integral of t * g(t) equals integral of (t - a) * g(t) -/

lemma integral_t_g_eq_integral_product (f : ℝ → ℝ) (hf : ValidFunction f) :
    let A := ∫ t in (0:ℝ)..1, f t
    let B := ∫ t in (0:ℝ)..1, (f t)^2
    let a := root_a f hf
    ∫ t in (0:ℝ)..1, t * aux_g f A B t = ∫ t in (0:ℝ)..1, (t - a) * aux_g f A B t := by
  intro A B a
  have hA_pos := integral_f_pos f hf
  have hB_pos := integral_f_sq_pos f hf
  have hint_zero := aux_g_integral_zero f hf
  have hprod : IntervalIntegrable (fun t => (t - a) * aux_g f A B t) volume 0 1 :=
    integrable_product f hf
  have hg_int : IntervalIntegrable (aux_g f A B) volume 0 1 :=
    (aux_g_continuousOn f hf A B (ne_of_gt hA_pos) (ne_of_gt hB_pos)).intervalIntegrable_of_Icc (by norm_num : (0:ℝ) ≤ 1)
  have hconst : IntervalIntegrable (fun t => a * aux_g f A B t) volume 0 1 :=
    hg_int.const_mul a
  have heq : (fun t => t * aux_g f A B t) = (fun t => (t - a) * aux_g f A B t + a * aux_g f A B t) := by
    ext t; ring
  rw [heq, intervalIntegral.integral_add hprod hconst]
  have h2 : ∫ t in (0:ℝ)..1, a * aux_g f A B t = 0 := by
    rw [intervalIntegral.integral_const_mul, hint_zero, mul_zero]
  simp only [h2, add_zero]

/-! ## Positivity of the key integral -/

lemma integral_product_pos (f : ℝ → ℝ) (hf : ValidFunction f) :
    let A := ∫ t in (0:ℝ)..1, f t
    let B := ∫ t in (0:ℝ)..1, (f t)^2
    let a := root_a f hf
    ∫ t in (0:ℝ)..1, (t - a) * aux_g f A B t > 0 := by
  intro A B a
  have hA_pos := integral_f_pos f hf
  have hB_pos := integral_f_sq_pos f hf
  have ha_mem := root_a_mem f hf
  have hcont : ContinuousOn (fun t => (t - a) * aux_g f A B t) (Set.Icc 0 1) := by
    apply ContinuousOn.mul
    · exact (continuous_sub_right a).continuousOn
    · exact aux_g_continuousOn f hf A B (ne_of_gt hA_pos) (ne_of_gt hB_pos)
  apply intervalIntegral.integral_pos
  · norm_num
  · exact hcont
  · -- Nonneg on Ioc 0 1
    intro t ht
    by_cases ht1 : t ≥ 1
    · have ht_eq : t = 1 := le_antisymm ht.2 ht1
      have h1a : 1 - a > 0 := sub_pos.mpr ha_mem.2
      have hg1_pos : aux_g f A B 1 > 0 := by
        have hf1_pos := f1_pos f hf
        rw [aux_g_factor f A B (ne_of_gt hA_pos) (ne_of_gt hB_pos) 1]
        have h1 : f 1 / B > 0 := div_pos hf1_pos hB_pos
        have h2 : f 1 - B / A > 0 := sub_pos.mpr (BA_lt_f1 f hf)
        exact mul_pos h1 h2
      rw [ht_eq]
      exact le_of_lt (mul_pos h1a hg1_pos)
    · push_neg at ht1
      exact product_nonneg_on_Ioc f hf t ⟨ht.1, le_of_lt ht1⟩
  · -- Positive at midpoint of (a, 1)
    use (a + 1) / 2
    refine ⟨⟨?_, ?_⟩, ?_⟩
    · linarith [ha_mem.1]
    · linarith [ha_mem.2]
    · have hmid_mem : (a + 1) / 2 ∈ Set.Ioc (0:ℝ) 1 := ⟨by linarith [ha_mem.1], by linarith [ha_mem.2]⟩
      have hmid_gt : (a + 1) / 2 > a := by linarith [ha_mem.2]
      exact product_pos_after f hf ((a + 1) / 2) hmid_mem hmid_gt

/-! ## Main Theorem -/

/-- Putnam 2025 B2: For any strictly increasing continuous f : [0,1] -> [0,∞),
    the centroid of the region under f has smaller x-coordinate than the centroid
    of the solid of revolution. -/
theorem putnam_2025_B2 (f : ℝ → ℝ) (hf : ValidFunction f) :
    centroid_region f < centroid_solid f := by
  have h_identity := key_integral_identity f hf
  have h_eq := integral_t_g_eq_integral_product f hf
  have h_pos := integral_product_pos f hf
  have h : centroid_solid f - centroid_region f > 0 := by
    calc centroid_solid f - centroid_region f
        = ∫ t in (0:ℝ)..1, t * aux_g f (∫ t in (0:ℝ)..1, f t) (∫ t in (0:ℝ)..1, (f t)^2) t := h_identity.symm
      _ = ∫ t in (0:ℝ)..1, (t - root_a f hf) * aux_g f (∫ t in (0:ℝ)..1, f t) (∫ t in (0:ℝ)..1, (f t)^2) t := h_eq
      _ > 0 := h_pos
  linarith

end Putnam2025B2
